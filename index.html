<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸‰å›½æ€ Lite - æ­¦ä¾ ç»ˆæç‰ˆ</title>
    <style>
        :root {
            --bg-color: #1a1a1a; /* æ°´å¢¨é»‘ */
            --panel-bg: rgba(44, 62, 80, 0.85);
            --paper-color: #f3e5ab; /* ç¾Šçš®çº¸è‰² */
            --gold: #d4af37;
            --red: #c0392b;
            --blue: #2980b9;
            --green: #27ae60;
            --text-color: #ecf0f1;
            --font-main: "Kaiti", "STKaiti", "KaiTi", "Georgia", serif; /* æ¥·ä½“/å®‹ä½“ */
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: var(--font-main);
            background: var(--bg-color);
            background-image: radial-gradient(circle at center, #2c3e50 0%, #000000 100%);
            color: var(--text-color);
            margin: 0; height: 100vh;
            display: flex; flex-direction: column;
            overflow: hidden;
        }

        /* --- é€šç”¨æ ·å¼ --- */
        button {
            font-family: var(--font-main);
            border: 1px solid var(--gold);
            background: #34495e; color: var(--gold);
            cursor: pointer; transition: all 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        button:active { transform: scale(0.95); background: #2c3e50; }
        button:disabled { opacity: 0.4; border-color: #7f8c8d; color: #bdc3c7; cursor: not-allowed; }

        /* --- é¡¶éƒ¨æ  --- */
        #top-bar {
            height: 40px; display: flex; justify-content: space-between; align-items: center;
            padding: 0 15px; background: rgba(0,0,0,0.6); border-bottom: 1px solid var(--gold);
        }
        .game-title { font-size: 18px; font-weight: bold; color: var(--gold); letter-spacing: 2px; }
        .top-btns { display: flex; gap: 10px; }
        .icon-btn { width: 28px; height: 28px; border-radius: 50%; font-size: 14px; display: flex; justify-content: center; align-items: center; }

        /* --- æ•Œæ–¹åŒºåŸŸ --- */
        #enemy-zone {
            flex: 0 0 28%; display: flex; justify-content: space-around; align-items: center;
            padding: 10px 5px; border-bottom: 1px solid #555;
        }

        .enemy-card {
            width: 30%; height: 100%;
            background: #2c3e50; border: 2px solid #555; border-radius: 4px;
            display: flex; flex-direction: column; align-items: center;
            position: relative; transition: all 0.3s;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.8);
        }
        .enemy-card.active-turn { border-color: var(--gold); box-shadow: 0 0 15px var(--gold); transform: scale(1.05); z-index: 2; }
        .enemy-card.dead { opacity: 0.4; filter: grayscale(100%); border-style: dashed; }
        .enemy-card.targetable { border-color: var(--red); box-shadow: 0 0 15px var(--red); animation: shake 0.5s infinite; }

        .avatar-frame {
            width: 100%; height: 55%;
            display: flex; justify-content: center; align-items: center;
            font-size: 36px; background: #34495e; border-bottom: 1px solid #555;
            position: relative;
        }
        .role-badge { 
            position: absolute; top: 2px; right: 2px; font-size: 10px; padding: 1px 4px; 
            background: #000; border: 1px solid #777; color: #fff;
        }

        .info-block { width: 100%; flex: 1; display: flex; flex-direction: column; justify-content: space-around; align-items: center; padding: 2px; }
        .general-name { font-size: 14px; font-weight: bold; color: var(--paper-color); text-shadow: 1px 1px 2px black; }
        
        /* --- æ—¥å¿—åŒºåŸŸ (å·è½´é£æ ¼) --- */
        #log-zone {
            flex: 1; background: rgba(0, 0, 0, 0.4);
            overflow-y: auto; padding: 10px 15px;
            font-size: 14px; color: #bdc3c7;
            border-bottom: 1px solid #555;
            font-family: "Courier New", Courier, monospace; /* æ‰“å­—æœºé£æ ¼ */
        }
        .log-line { margin-bottom: 5px; }
        .log-turn { color: var(--gold); margin-top: 8px; border-top: 1px dashed #555; padding-top: 4px; font-weight: bold; }
        .log-damage { color: var(--red); }
        .log-skill { color: var(--blue); }

        /* --- ç©å®¶åŒºåŸŸ --- */
        #player-zone {
            flex: 0 0 40%; display: flex; flex-direction: column;
            background: rgba(20, 20, 20, 0.9); padding: 5px;
            border-top: 2px solid var(--gold);
        }

        #player-status { display: flex; justify-content: space-between; align-items: center; padding: 0 10px; height: 35px; }
        .my-info { display: flex; align-items: center; gap: 10px; }
        .my-name { font-size: 18px; color: var(--gold); font-weight: bold; }
        
        .hp-bar { display: flex; gap: 3px; }
        .hp-point { 
            width: 14px; height: 14px; border-radius: 50%; 
            background: radial-gradient(circle at 30% 30%, #2ecc71, #27ae60); 
            border: 1px solid #fff; box-shadow: 0 0 3px black; 
        }
        .hp-lost { background: #444; border-color: #666; }

        /* æ‰‹ç‰Œ (æ¨ªå‘) */
        #hand-scroll-container {
            flex: 1; overflow-x: auto; white-space: nowrap;
            padding: 10px 5px; display: flex; align-items: center;
        }

        .card {
            display: inline-flex; flex-direction: column; justify-content: center; align-items: center;
            width: 70px; height: 100px;
            background: var(--paper-color); 
            border-radius: 4px; margin-right: 8px; flex-shrink: 0;
            position: relative;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.6);
            transition: transform 0.2s;
            color: #333; font-weight: bold; border: 1px solid #d7ccc8;
        }
        .card.selected { transform: translateY(-15px); border: 2px solid var(--red); box-shadow: 0 0 15px var(--red); }

        .card[data-type="æ€"] { color: #8b0000; }
        .card[data-type="é—ª"] { color: #154360; }
        .card[data-type="æ¡ƒ"] { color: #d81b60; }
        .card[data-type="é…’"] { color: #a04000; }
        .card[data-type="ä¸‡ç®­"] { color: #6c3483; }
        .card[data-type="å—è›®"] { color: #d35400; }
        .card[data-type="æ— ä¸­"] { color: #1e8449; }
        .card[data-type="é¡ºæ‰‹"] { color: #117864; }
        .card[data-type="æ‹†æ¡¥"] { color: #873600; }
        .card[data-type="æ¡ƒå›­"] { color: #c2185b; }
        .card[data-type="å†³æ–—"] { color: #7d6608; }
        .card[data-type="å…µç²®"] { color: #9c640c; }

        .card-icon { font-size: 28px; margin-bottom: 5px; }
        .card-text { font-family: var(--font-main); font-size: 16px; }

        /* åº•éƒ¨æŒ‰é’® */
        #controls { height: 50px; display: flex; gap: 10px; padding: 5px; }
        .btn-action { flex: 1; font-size: 16px; font-weight: bold; border-radius: 4px; color: white; }
        #btn-confirm { background: #d35400; border-color: #e67e22; }
        #btn-end { background: #27ae60; border-color: #2ecc71; }
        #btn-cancel { background: #7f8c8d; border-color: #95a5a6; }

        /* --- å¼¹çª— --- */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }

        /* é€‰å°†ç•Œé¢ */
        #select-screen { display: flex; }
        .select-title { font-size: 24px; color: var(--gold); margin-bottom: 20px; text-align: center; }
        .hero-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; }
        .hero-option {
            width: 100px; height: 140px;
            background: #34495e; border: 2px solid #7f8c8d; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: transform 0.2s;
        }
        .hero-option:hover { transform: scale(1.1); border-color: var(--gold); box-shadow: 0 0 20px var(--gold); }
        .hero-avatar { font-size: 40px; margin-bottom: 10px; }
        .hero-name { font-weight: bold; color: white; }
        .hero-skill { font-size: 12px; color: #bdc3c7; margin-top: 5px; }

        .role-picker { display: flex; gap: 10px; justify-content: center; margin-bottom: 15px; flex-wrap: wrap; }
        .role-option {
            padding: 6px 12px; border: 1px solid #7f8c8d; border-radius: 6px;
            color: white; cursor: pointer; font-weight: bold; background: rgba(0,0,0,0.35);
        }
        .role-option.active { border-color: var(--gold); color: var(--gold); box-shadow: 0 0 10px var(--gold); }

        /* ç»“ç®—ç•Œé¢ */
        #result-title { font-size: 40px; margin-bottom: 20px; font-family: var(--font-main); }
        .win { color: var(--gold); text-shadow: 0 0 10px var(--gold); }
        .lose { color: var(--red); text-shadow: 0 0 10px var(--red); }

        @keyframes shake { 0% { transform: rotate(0deg); } 25% { transform: rotate(2deg); } 75% { transform: rotate(-2deg); } 100% { transform: rotate(0deg); } }

    </style>
</head>
<body>

    <!-- é¡¶éƒ¨æ  -->
    <div id="top-bar">
        <div class="game-title">ä¸‰å›½æ€Â·ä¾ ä¹‰ç¯‡</div>
        <div class="top-btns">
            <button class="icon-btn" onclick="toggleSound()" id="btn-sound">ğŸ”Š</button>
            <button class="icon-btn" onclick="showHelp()">?</button>
        </div>
    </div>

    <!-- æ•Œæ–¹åŒºåŸŸ -->
    <div id="enemy-zone"></div>

    <!-- æ—¥å¿— -->
    <div id="log-zone">
        <div class="log-line">è¯·é€‰æ‹©ä½ çš„æ­¦å°†å¼€å§‹æ¸¸æˆ...</div>
    </div>

    <!-- ç©å®¶åŒºåŸŸ -->
    <div id="player-zone">
        <div id="player-status">
            <div class="my-info">
                <span id="my-avatar" style="font-size:24px;"></span>
                <span id="my-name" class="my-name"></span>
                <span id="my-skill" style="font-size:12px; color:#bdc3c7;"></span>
            </div>
            <div class="hp-bar" id="my-hp-bar"></div>
        </div>
        
        <div id="hand-scroll-container"></div>

        <div id="controls">
            <button id="btn-confirm" class="btn-action" onclick="confirmAction()" disabled>å‡ºç‰Œ</button>
            <button id="btn-cancel" class="btn-action" onclick="cancelAction()" disabled>å–æ¶ˆ</button>
            <button id="btn-end" class="btn-action" onclick="endTurn()" disabled>ç»“æŸ</button>
        </div>
    </div>

    <!-- é€‰å°†/é€‰èº«ä»½å¼¹çª— -->
    <div id="select-screen" class="overlay">
        <div class="select-title">è¯·é€‰æ‹©ä½ çš„èº«ä»½ä¸æ­¦å°†</div>
        <div class="role-picker" id="role-picker"></div>
        <div class="hero-container" id="hero-selection">
            <!-- JSç”Ÿæˆ -->
        </div>
    </div>

    <!-- ç»“ç®—å¼¹çª— -->
    <div id="result-overlay" class="overlay">
        <div id="result-title"></div>
        <button class="btn-action" style="flex:0; padding:10px 30px;" onclick="location.reload()">å†æˆ˜æ±Ÿæ¹–</button>
    </div>

    <!-- å¸®åŠ©å¼¹çª— -->
    <div id="help-overlay" class="overlay" onclick="this.style.display='none'">
        <div style="background:var(--paper-color); color:#333; padding:20px; border-radius:5px; max-width:80%; max-height:80%; overflow-y:auto;">
            <h2 style="text-align:center; margin-top:0;">æ±Ÿæ¹–è§„çŸ©</h2>
            <p><b>èº«ä»½</b>ï¼šä¸»å…¬ã€å¿ è‡£ã€åè´¼ã€å†…å¥¸ã€‚ä½ å¯è‡ªç”±é€‰æ‹©å…¶ä¸€ã€‚</p>
            <p><b>å¡ç‰Œ</b>ï¼š<br>
            âš”ï¸ æ€ï¼šæ”»å‡» (éœ€é—ª)<br>
            ğŸ’¨ é—ªï¼šé˜²å¾¡<br>
            ğŸ‘ æ¡ƒï¼šå›è¡€<br>
            ğŸ¶ é…’ï¼šå›è¡€å¹¶å¯å†å‡ºä¸€å¼ æ€<br>
            ğŸ¹ ä¸‡ç®­ï¼šå…¨åœºéœ€é—ª<br>
            ğŸ˜ å—è›®ï¼šå…¨åœºéœ€æ€<br>
            ğŸ”— é¡ºæ‰‹ï¼šé¡ºæ‰‹ç‰µç¾Šä¸€å¼ ç‰Œ<br>
            ğŸª“ æ‹†æ¡¥ï¼šè¿‡æ²³æ‹†æ¡¥å¼ƒä¸€å¼ ç‰Œ<br>
            ğŸ§§ æ¡ƒå›­ï¼šç¾¤ä½“å›å¤<br>
            âš–ï¸ å†³æ–—ï¼šé€¼è¿«å¯¹æ‰‹äº¤å‡ºã€æ€ã€‘æˆ–å—ä¼¤<br>
            ğŸŒ¾ å…µç²®ï¼šä»¤ç›®æ ‡ä¸‹å›åˆæ— æ³•æ‘¸ç‰Œ<br>
            ğŸ æ— ä¸­ï¼šæ‘¸2ç‰Œ</p>
            <p style="text-align:center; color:#7f8c8d;">(ç‚¹å‡»ä»»æ„å¤„å…³é—­)</p>
        </div>
    </div>

<script>
    // --- éŸ³æ•ˆç³»ç»Ÿ (Web Audio API) ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let soundEnabled = true;

    function toggleSound() {
        soundEnabled = !soundEnabled;
        document.getElementById('btn-sound').innerText = soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
        if (soundEnabled) startBgm(); else stopBgm();
    }

    function playTone(freq, type, duration, vol=0.1) {
        if (!soundEnabled) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    let bgmSource = null;
    const SFX = {
        card: () => { // çº¸å¼ å£° (ç™½å™ªéŸ³æ¨¡æ‹Ÿ)
            if (!soundEnabled) return;
            const bufferSize = audioCtx.sampleRate * 0.1;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gain = audioCtx.createGain();
            gain.gain.value = 0.1;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            noise.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
        },
        attack: () => playTone(600, 'sawtooth', 0.1, 0.1), // é”åˆ©
        damage: () => playTone(100, 'square', 0.3, 0.2),   // ä½æ²‰
        heal: () => playTone(800, 'sine', 0.5, 0.1),       // æ¸…è„†
        aoe: () => { playTone(200, 'sawtooth', 0.4, 0.1); setTimeout(()=>playTone(150, 'sawtooth', 0.4, 0.1), 100); },
        win: () => { playTone(400, 'triangle', 0.2); setTimeout(()=>playTone(600, 'triangle', 0.4), 200); },
        lose: () => { playTone(300, 'sawtooth', 0.5); setTimeout(()=>playTone(200, 'sawtooth', 0.5), 400); }
    };

    function startBgm() {
        if (!soundEnabled || bgmSource) return;
        audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 180;
        gain.gain.setValueAtTime(0.01, audioCtx.currentTime);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        bgmSource = { osc, gain };
    }

    function stopBgm() {
        if (!bgmSource) return;
        bgmSource.osc.stop();
        bgmSource = null;
    }

    // --- æ¸¸æˆæ•°æ® ---
    const ROLE_POOL = ['ä¸»å…¬', 'å¿ è‡£', 'åè´¼', 'å†…å¥¸'];
    const GENERALS_DATA = [
        { name: 'æ›¹æ“', hp: 5, skill: 'å¥¸é›„', desc: 'å—ä¼¤æ‘¸ç‰Œ', avatar: 'ğŸ‘‘', color: '#8e44ad' },
        { name: 'å¼ é£', hp: 4, skill: 'å’†å“®', desc: 'æ— é™å‡ºæ€', avatar: 'ğŸ‘¹', color: '#c0392b' },
        { name: 'éƒ­å˜‰', hp: 3, skill: 'é—è®¡', desc: 'å—ä¼¤æ‘¸2', avatar: 'ğŸ”®', color: '#2980b9' },
        { name: 'èµµäº‘', hp: 4, skill: 'é¾™èƒ†', desc: 'æ”»å®ˆå…¼å¤‡', avatar: 'ğŸ›¡ï¸', color: '#95a5a6' },
        { name: 'å•å¸ƒ', hp: 5, skill: 'æ— åŒ', desc: 'æ€éœ€2é—ª', avatar: 'ğŸ”¥', color: '#e74c3c' },
        { name: 'åä½—', hp: 3, skill: 'æ€¥æ•‘', desc: 'å›åˆå¤–å›è¡€', avatar: 'ğŸŒ¿', color: '#27ae60' },
        { name: 'åˆ˜å¤‡', hp: 4, skill: 'ä»å¾·', desc: 'å¼€å±€é¢å¤–æ‘¸ç‰Œ', avatar: 'ğŸ‰', color: '#2ecc71' },
        { name: 'å‘¨ç‘œ', hp: 4, skill: 'ä¸šç‚', desc: 'AOEåæ‘¸ç‰Œ', avatar: 'ğŸ”¥', color: '#e67e22' },
        { name: 'è®¸è¤š', hp: 4, skill: 'è£¸è¡£', desc: 'æ€æ›´éš¾é—ª', avatar: 'ğŸ›¡ï¸', color: '#7f8c8d' }
    ];

    const DECK_TEMPLATE = [
        ...Array(20).fill('æ€'), ...Array(10).fill('é—ª'), ...Array(8).fill('æ¡ƒ'), ...Array(4).fill('é…’'),
        ...Array(2).fill('ä¸‡ç®­'), ...Array(2).fill('å—è›®'), ...Array(3).fill('æ— ä¸­'),
        ...Array(3).fill('é¡ºæ‰‹'), ...Array(3).fill('æ‹†æ¡¥'),
        ...Array(2).fill('æ¡ƒå›­'), ...Array(3).fill('å†³æ–—'), ...Array(3).fill('å…µç²®')
    ];

    let players = [];
    let deck = [];
    let currentTurnIndex = 0;
    let selectedCardIndex = -1;
    let isTargetingMode = false;
    let gameActive = false;
    let selectedRole = 'ä¸»å…¬';

    function requiresTarget(card) {
        return ['æ€', 'é¡ºæ‰‹', 'æ‹†æ¡¥', 'å†³æ–—', 'å…µç²®'].includes(card);
    }

    // --- é€‰å°†é€»è¾‘ ---
    function showSelection() {
        const roleBox = document.getElementById('role-picker');
        roleBox.innerHTML = '';
        ROLE_POOL.forEach(r => {
            const btn = document.createElement('div');
            btn.className = `role-option ${selectedRole===r?'active':''}`;
            btn.innerText = r;
            btn.onclick = () => { selectedRole = r; showSelection(); };
            roleBox.appendChild(btn);
        });

        const container = document.getElementById('hero-selection');
        container.innerHTML = '';
        // éšæœºå–4ä¸ªä¾›é€‰æ‹©
        let pool = [...GENERALS_DATA];
        shuffle(pool);
        const options = pool.slice(0, 4);

        options.forEach(hero => {
            const el = document.createElement('div');
            el.className = 'hero-option';
            el.innerHTML = `
                <div class="hero-avatar" style="color:${hero.color}">${hero.avatar}</div>
                <div class="hero-name">${hero.name}</div>
                <div class="hero-skill">${hero.skill}</div>
            `;
            el.onclick = () => startGame(hero, selectedRole);
            container.appendChild(el);
        });
        document.getElementById('select-screen').style.display = 'flex';
    }

    function startGame(selectedHero, role) {
        document.getElementById('select-screen').style.display = 'none';
        gameActive = true;
        SFX.win(); // å¼€å±€éŸ³æ•ˆ
        startBgm();

        // 1. åˆå§‹åŒ–ç‰Œå †
        deck = [...DECK_TEMPLATE];
        shuffle(deck);

        // 2. è§’è‰²åˆ†é…
        let aiRoles = ROLE_POOL.filter(r => r !== role);
        shuffle(aiRoles);
        
        // 3. æ­¦å°†åˆ†é… (æ’é™¤ç©å®¶é€‰çš„)
        let aiPool = GENERALS_DATA.filter(g => g.name !== selectedHero.name);
        shuffle(aiPool);

        // 4. æ„å»ºç©å®¶
        players = [];
        // ç©å®¶
        players.push({
            id: 0, isUser: true, role: role, general: selectedHero,
            hp: selectedHero.hp, maxHp: selectedHero.hp, hand: [], isDead: false, hasAttacked: false, berserk: false, skipDraw: false
        });
        // AI
        for(let i=0; i<3; i++) {
            players.push({
                id: i+1, isUser: false, role: aiRoles[i], general: aiPool[i],
                hp: aiPool[i].hp, maxHp: aiPool[i].hp, hand: [], isDead: false, hasAttacked: false, identityKnown: false, berserk: false, skipDraw: false
            });
        }

        // 5. å‘ç‰Œ
        players.forEach(p => drawCards(p, 4));

        // 6. UIåˆå§‹åŒ–
        document.getElementById('my-avatar').innerText = selectedHero.avatar;
        document.getElementById('my-name').innerText = `${selectedHero.name} / ${role}`;
        document.getElementById('my-skill').innerText = `[${selectedHero.skill}]`;
        
        renderAll();
        log(`æ±Ÿæ¹–é£èµ·äº‘æ¶Œï¼Œ${selectedHero.name}ï¼ˆ${role}ï¼‰è¸å…¥æˆ˜åœºï¼`, "turn");
        startTurn(0);
    }

    // --- æ ¸å¿ƒæµç¨‹ ---
    function startTurn(idx) {
        if (!gameActive) return;
        currentTurnIndex = idx;
        const p = players[idx];

        if (p.isDead) { nextTurn(); return; }

        p.hasAttacked = false;
        p.berserk = false;
        if (p.general.name === 'åˆ˜å¤‡') { log(`ã€ä»å¾·ã€‘${p.general.name} ä»å¿ƒæ˜­æ˜­ï¼Œå†æ‘¸1ç‰Œ`, 'skill'); drawCards(p, 1); }
        renderAll();
        log(`--- ${p.general.name} å›åˆ ---`, "turn");
        if (p.skipDraw) { log(`${p.general.name} è¢«å…µç²®å¯¸æ–­ï¼Œè·³è¿‡æ‘¸ç‰Œ`, 'skill'); p.skipDraw = false; }
        else drawCards(p, 2);

        if (p.isUser) {
            updateHandUI();
            updateButtons();
        } else {
            updateButtons();
            setTimeout(() => aiAction(p), 1000);
        }
    }

    function nextTurn() {
        checkWin();
        if (!gameActive) return;
        startTurn((currentTurnIndex + 1) % 4);
    }

    // --- ç©å®¶æ“ä½œ ---
    function selectCard(idx) {
        if (!players[0].isUser || currentTurnIndex !== 0) return;
        SFX.card();
        if (selectedCardIndex === idx) {
            cancelAction();
        } else {
            selectedCardIndex = idx;
            const card = players[0].hand[idx];
            isTargetingMode = requiresTarget(card);
            if (isTargetingMode) log("è¯·ç‚¹å‡»ä¸Šæ–¹å¤´åƒé€‰æ‹©ç›®æ ‡");
            updateHandUI();
            updateButtons();
            renderEnemies();
        }
    }

    function selectTarget(id) {
        if (!isTargetingMode || selectedCardIndex === -1) return;
        const target = players[id];
        if (target.isDead) return;

        const p = players[0];
        const card = p.hand[selectedCardIndex];
        if (card === 'æ€') {
            if (p.hasAttacked && p.general.name !== 'å¼ é£') {
                log("æœ¬å›åˆå·²å‡ºè¿‡æ€"); cancelAction(); return;
            }
            useCard(p, selectedCardIndex, target);
            cancelAction();
        } else if (['é¡ºæ‰‹', 'æ‹†æ¡¥', 'å†³æ–—', 'å…µç²®'].includes(card)) {
            useCard(p, selectedCardIndex, target);
            cancelAction();
        }
    }

    function confirmAction() {
        const p = players[0];
        const card = p.hand[selectedCardIndex];
        if (card === 'æ¡ƒ' || card === 'é…’') useCard(p, selectedCardIndex, p);
        else useCard(p, selectedCardIndex, null); // AOE or Draw
        cancelAction();
    }

    function cancelAction() {
        selectedCardIndex = -1; isTargetingMode = false;
        updateHandUI(); updateButtons(); renderEnemies();
    }

    function endTurn() { if (currentTurnIndex === 0) nextTurn(); }

    // --- æˆ˜æ–—é€»è¾‘ ---
    function useCard(source, idx, target) {
        const card = source.hand[idx];
        source.hand.splice(idx, 1);
        SFX.card();

        if (card === 'æ€') {
            log(`${source.general.name} å¯¹ ${target.general.name} å‡ºã€æ€ã€‘`);
            SFX.attack();
            source.hasAttacked = true;
            resolveAttack(source, target, 'sha');
            if (source.berserk) { source.hasAttacked = false; source.berserk = false; log(`ã€é…’åŠ²ã€‘${source.general.name} ä»å¯å†å‡ºæ€`, 'skill'); }
        } else if (card === 'æ¡ƒ') {
            if (target.hp < target.maxHp) {
                target.hp++;
                log(`${source.general.name} åƒã€æ¡ƒã€‘å›è¡€`, "skill");
                SFX.heal();
            } else log(`${source.general.name} æ»¡è¡€åƒæ¡ƒæ— æ•ˆ`);
        } else if (card === 'é…’') {
            if (target.hp < target.maxHp) {
                target.hp++;
                log(`${source.general.name} é¥®ã€é…’ã€‘å›å¤ä½“åŠ›`, 'skill');
                SFX.heal();
            }
            source.berserk = true;
            log(`${source.general.name} é…’æ°”ä¸Šæ¶Œï¼Œæ€åŠ¿æ›´çŒ›`, 'skill');
        } else if (card === 'ä¸‡ç®­' || card === 'å—è›®') {
            log(`${source.general.name} é‡Šæ”¾ã€${card}ã€‘`, "skill");
            SFX.aoe();
            players.forEach(p => {
                if (p !== source && !p.isDead) resolveAttack(source, p, card === 'ä¸‡ç®­' ? 'wanjian' : 'nanman');
            });
            if (source.general.name === 'å‘¨ç‘œ') { log(`ã€ä¸šç‚ã€‘${source.general.name} AOEåç¥é‡‡å¥•å¥•ï¼Œæ‘¸1ç‰Œ`, 'skill'); drawCards(source, 1); }
        } else if (card === 'æ— ä¸­') {
            log(`${source.general.name} ã€æ— ä¸­ç”Ÿæœ‰ã€‘`, "skill");
            SFX.heal();
            drawCards(source, 2);
        } else if (card === 'æ¡ƒå›­') {
            log(`${source.general.name} å‘åŠ¨ã€æ¡ƒå›­ç»“ä¹‰ã€‘ï¼Œä¼—äººå„è‡ªç–—ä¼¤`, 'skill');
            SFX.heal();
            players.forEach(p => {
                if (!p.isDead && p.hp < p.maxHp) p.hp++;
            });
        } else if (card === 'å†³æ–—') {
            if (target.isDead) return;
            log(`${source.general.name} å‘ ${target.general.name} å‘èµ·ã€å†³æ–—ã€‘`, 'skill');
            const idx = target.hand.indexOf('æ€');
            if (idx !== -1) {
                target.hand.splice(idx, 1);
                log(`${target.general.name} æ‰“å‡ºã€æ€ã€‘èµ¢å¾—å†³æ–—`, 'skill');
            } else {
                target.hp--;
                SFX.damage();
                log(`${target.general.name} å†³æ–—å¤±è´¥ï¼Œå—åˆ°1ç‚¹ä¼¤å®³`, 'damage');
                if (target.hp <= 0) handleDeath(source, target);
            }
        } else if (card === 'å…µç²®') {
            log(`${source.general.name} æ–½æ”¾ã€å…µç²®å¯¸æ–­ã€‘å½±å“ ${target.general.name}`, 'skill');
            target.skipDraw = true;
        } else if (card === 'é¡ºæ‰‹') {
            if (target.hand.length > 0) {
                const stealIdx = Math.floor(Math.random() * target.hand.length);
                const got = target.hand.splice(stealIdx, 1)[0];
                source.hand.push(got);
                log(`${source.general.name} ä½¿å‡ºã€é¡ºæ‰‹ç‰µç¾Šã€‘ï¼Œè·å¾— ${target.general.name} çš„ä¸€å¼ ç‰Œ`, 'skill');
            } else {
                log(`${target.general.name} ç©ºæ‰‹ï¼Œé¡ºæ‰‹æ— åŠŸ`);
            }
        } else if (card === 'æ‹†æ¡¥') {
            if (target.hand.length > 0) {
                const discardIdx = Math.floor(Math.random() * target.hand.length);
                target.hand.splice(discardIdx, 1);
                log(`${source.general.name} æ–½å±•ã€è¿‡æ²³æ‹†æ¡¥ã€‘ï¼Œå¼ƒç½® ${target.general.name} ä¸€å¼ ç‰Œ`, 'skill');
            } else {
                log(`${target.general.name} ç©ºæ‰‹ï¼Œæ‹†æ¡¥è½ç©º`);
            }
        }
        renderAll();
    }

    function resolveAttack(source, target, type) {
        let need = type === 'nanman' ? 'æ€' : 'é—ª';
        let idx = target.hand.indexOf(need);

        // å•å¸ƒæŠ€èƒ½ï¼šæ— åŒ (ç®€å•æ¨¡æ‹Ÿï¼šå¦‚æœæºæ˜¯å•å¸ƒï¼Œä¸”æ˜¯æ€ï¼Œéœ€è¦2å¼ é—ªï¼Œè¿™é‡Œç®€åŒ–ä¸ºå¯¹æ–¹å¾ˆéš¾é—ª)
        // è®¸è¤šæŠ€èƒ½ï¼šè£¸è¡£ (ä½¿å¯¹æ–¹æ›´éš¾é—ª)
        if ((source.general.name === 'å•å¸ƒ' || source.general.name === 'è®¸è¤š') && type === 'sha') {
            // ç®€åŒ–ï¼šå•å¸ƒçš„æ€æœ‰50%æ¦‚ç‡æ— è§†é—ª
            if (Math.random() > 0.5) idx = -1;
        }

        // èµµäº‘æŠ€èƒ½ï¼šé¾™èƒ† (æ€å½“é—ªï¼Œé—ªå½“æ€)
        if (target.general.name === 'èµµäº‘' && idx === -1) {
            if (need === 'é—ª') idx = target.hand.indexOf('æ€');
            else idx = target.hand.indexOf('é—ª');
        }

        if (idx !== -1) {
            target.hand.splice(idx, 1);
            log(`${target.general.name} æ‰“å‡ºã€${need}ã€‘æŠµæ¶ˆ`, "skill");
            SFX.card();
        } else {
            target.hp--;
            log(`${target.general.name} å—åˆ°ä¼¤å®³`, "damage");
            SFX.damage();
            triggerDamageSkill(target);
            if (target.hp <= 0) {
                const tao = target.hand.indexOf('æ¡ƒ');
                if (tao !== -1) {
                    target.hand.splice(tao, 1);
                    target.hp++;
                    log(`${target.general.name} æ¿’æ­»åƒæ¡ƒ`, "skill");
                    SFX.heal();
                } else handleDeath(source, target);
            }
        }
    }

    function triggerDamageSkill(p) {
        if (p.isDead) return;
        if (p.general.name === 'æ›¹æ“') { log(`ã€å¥¸é›„ã€‘${p.general.name}æ‘¸1ç‰Œ`, "skill"); drawCards(p, 1); }
        if (p.general.name === 'éƒ­å˜‰') { log(`ã€é—è®¡ã€‘${p.general.name}æ‘¸2ç‰Œ`, "skill"); drawCards(p, 2); }
    }

    function handleDeath(killer, dead) {
        dead.isDead = true; dead.identityKnown = true;
        log(`${dead.general.name} é˜µäº¡! èº«ä»½: ${dead.role}`, "damage");
        if (dead.role === 'åè´¼') drawCards(killer, 3);
        else if (dead.role === 'å¿ è‡£' && killer.role === 'ä¸»å…¬') killer.hand = [];
        checkWin();
    }

    // --- AI ---
    function aiAction(ai) {
        if (ai.isDead || !gameActive) return;
        
        // 1. æ— ä¸­
        if (ai.hand.includes('æ— ä¸­')) { useCard(ai, ai.hand.indexOf('æ— ä¸­'), null); if(!gameActive) return; }
        // 2. æ¡ƒ
        while (ai.hp < ai.maxHp && ai.hand.includes('æ¡ƒ')) useCard(ai, ai.hand.indexOf('æ¡ƒ'), ai);
        // 3. é…’
        if (ai.hand.includes('é…’') && (ai.hp < ai.maxHp || (ai.hand.includes('æ€') && ai.hasAttacked))) { useCard(ai, ai.hand.indexOf('é…’'), ai); }
        // 4. AOE
        if (ai.hand.includes('ä¸‡ç®­')) { useCard(ai, ai.hand.indexOf('ä¸‡ç®­'), null); if(!gameActive) return; }
        if (ai.hand.includes('å—è›®')) { useCard(ai, ai.hand.indexOf('å—è›®'), null); if(!gameActive) return; }

        const alive = players.filter(p => !p.isDead && p !== ai);
        const lord = players.find(p => p.role === 'ä¸»å…¬' && !p.isDead);
        let target = null;
        if (ai.role === 'åè´¼') target = lord || alive[Math.floor(Math.random()*alive.length)];
        else if (ai.role === 'å¿ è‡£' || ai.role === 'ä¸»å…¬') {
            const enemies = alive.filter(p => p.role === 'åè´¼' || p.role === 'å†…å¥¸');
            if (enemies.length) target = enemies[Math.floor(Math.random()*enemies.length)];
        } else target = alive[Math.floor(Math.random()*alive.length)];

        // 1. æ¡ƒå›­
        if (ai.hand.includes('æ¡ƒå›­')) {
            const needHeal = players.some(p => !p.isDead && p.hp < p.maxHp);
            if (needHeal) { useCard(ai, ai.hand.indexOf('æ¡ƒå›­'), null); if(!gameActive) return; }
        }

        // 5. å…µç²®/å†³æ–—
        if (target && ai.hand.includes('å…µç²®')) { useCard(ai, ai.hand.indexOf('å…µç²®'), target); }
        if (target && ai.hand.includes('å†³æ–—')) { useCard(ai, ai.hand.indexOf('å†³æ–—'), target); if(!gameActive) return; }

        // 6. é¡ºæ‰‹/æ‹†æ¡¥
        const stealTarget = alive.filter(p => p.hand.length > 0 && p !== ai);
        if (ai.hand.includes('é¡ºæ‰‹') && stealTarget.length) {
            const t = stealTarget[Math.floor(Math.random()*stealTarget.length)];
            useCard(ai, ai.hand.indexOf('é¡ºæ‰‹'), t);
        }
        if (ai.hand.includes('æ‹†æ¡¥') && stealTarget.length) {
            const t = stealTarget[Math.floor(Math.random()*stealTarget.length)];
            useCard(ai, ai.hand.indexOf('æ‹†æ¡¥'), t);
        }

        // 7. æ€
        if (target && !target.isDead && ai.hand.includes('æ€')) {
            if (!ai.hasAttacked || ai.general.name === 'å¼ é£') useCard(ai, ai.hand.indexOf('æ€'), target);
        }
        setTimeout(nextTurn, 800);
    }

    // --- è¾…åŠ© ---
    function drawCards(p, n) {
        for(let i=0; i<n; i++) {
            if (deck.length===0) { deck=[...DECK_TEMPLATE]; shuffle(deck); }
            p.hand.push(deck.pop());
        }
    }
    function shuffle(arr) { for(let i=arr.length-1; i>0; i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
    function log(msg, type="") {
        const box = document.getElementById('log-zone');
        const div = document.createElement('div');
        div.className = `log-line ${type==='turn'?'log-turn':(type==='damage'?'log-damage':(type==='skill'?'log-skill':''))}`;
        div.innerText = msg;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    }
    function checkWin() {
        const user = players[0];
        const lord = players.find(p => p.role === 'ä¸»å…¬');
        const lordAlive = lord && !lord.isDead;
        const rebelsAlive = players.filter(p => p.role === 'åè´¼' && !p.isDead);
        const traitorsAlive = players.filter(p => p.role === 'å†…å¥¸' && !p.isDead);
        const survivors = players.filter(p => !p.isDead);

        if (!lordAlive) {
            if (traitorsAlive.length === 1 && survivors.length === 1) gameOver(user.role === 'å†…å¥¸', 'ä¸»å…¬é™¨è½ï¼Œå†…å¥¸å¾—åŠ¿ï¼');
            else gameOver(user.role === 'åè´¼', 'ä¸»å…¬å€’ä¸‹ï¼Œåè´¼èƒœå‡ºï¼');
        } else if (rebelsAlive.length === 0 && traitorsAlive.length === 0) {
            gameOver(user.role === 'ä¸»å…¬' || user.role === 'å¿ è‡£', 'é€†è´¼å…¨ç­ï¼Œç¤¾ç¨·å®‰ç¨³ï¼');
        }
    }
    function gameOver(win, msg) {
        gameActive = false;
        const t = document.getElementById('result-title');
        t.innerText = msg; t.className = win ? 'win' : 'lose';
        document.getElementById('result-overlay').style.display = 'flex';
        win ? SFX.win() : SFX.lose();
        stopBgm();
    }

    // --- æ¸²æŸ“ ---
    function renderAll() {
        const container = document.getElementById('enemy-zone');
        container.innerHTML = '';
        for(let i=1; i<=3; i++) {
            const p = players[i];
            const div = document.createElement('div');
            let roleText = p.identityKnown ? p.role : "???";
            let classes = `enemy-card ${p.isDead ? 'dead' : ''} ${currentTurnIndex === i ? 'active-turn' : ''}`;
            if (isTargetingMode && !p.isDead) classes += ' targetable';
            div.className = classes;
            div.onclick = () => selectTarget(i);
            div.innerHTML = `
                <div class="role-badge" style="background:${p.identityKnown?(p.role==='åè´¼'?'#2ecc71':(p.role==='å¿ è‡£'?'#e67e22':'#9b59b6')):'#333'}">${roleText}</div>
                <div class="avatar-frame" style="color:${p.general.color}">${p.general.avatar}</div>
                <div class="info-block">
                    <div class="general-name">${p.general.name}</div>
                    <div class="hp-bar">${getHpHtml(p.hp, p.maxHp)}</div>
                    <div style="font-size:10px; color:#7f8c8d;">æ‰‹ç‰Œ: ${p.hand.length}</div>
                </div>
            `;
            container.appendChild(div);
        }
        document.getElementById('my-hp-bar').innerHTML = getHpHtml(players[0].hp, players[0].maxHp);
        updateHandUI();
    }
    function getHpHtml(hp, max) {
        let h = ''; for(let i=0; i<max; i++) h += `<div class="hp-point ${i<hp?'':'hp-lost'}"></div>`; return h;
    }
    function updateHandUI() {
        const c = document.getElementById('hand-scroll-container'); c.innerHTML = '';
        players[0].hand.forEach((card, i) => {
            const el = document.createElement('div');
            el.className = `card ${i===selectedCardIndex?'selected':''}`;
            el.setAttribute('data-type', card);
            el.onclick = () => selectCard(i);
            let icon = '';
            if(card==='æ€') icon='âš”ï¸'; if(card==='é—ª') icon='ğŸ’¨'; if(card==='æ¡ƒ') icon='ğŸ‘'; if(card==='é…’') icon='ğŸ¶';
            if(card==='ä¸‡ç®­') icon='ğŸ¹'; if(card==='å—è›®') icon='ğŸ˜'; if(card==='æ— ä¸­') icon='ğŸ';
            if(card==='é¡ºæ‰‹') icon='ğŸ”—'; if(card==='æ‹†æ¡¥') icon='ğŸª“'; if(card==='æ¡ƒå›­') icon='ğŸ§§';
            if(card==='å†³æ–—') icon='âš–ï¸'; if(card==='å…µç²®') icon='ğŸŒ¾';
            el.innerHTML = `<div class="card-icon">${icon}</div><div class="card-text">${card}</div>`;
            c.appendChild(el);
        });
    }
    function updateButtons() {
        const isMyTurn = currentTurnIndex === 0;
        const hasSel = selectedCardIndex !== -1;
        const card = hasSel ? players[0].hand[selectedCardIndex] : null;
        document.getElementById('btn-end').disabled = !isMyTurn;
        document.getElementById('btn-cancel').disabled = !hasSel;
        let can = false;
        if (isMyTurn && hasSel) {
            if (card === 'æ¡ƒ' && players[0].hp < players[0].maxHp) can = true;
            if (card === 'é…’') can = true;
            if (['ä¸‡ç®­', 'å—è›®', 'æ— ä¸­', 'æ¡ƒå›­'].includes(card)) can = true;
        }
        document.getElementById('btn-confirm').disabled = !can;
    }

    // å¯åŠ¨é€‰å°†
    showSelection();

</script>
</body>
</html>
