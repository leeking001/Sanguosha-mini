<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸‰å›½æ€ Lite - æ‰‹æœºç‰ˆ</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --card-bg: #ecf0f1;
            --log-bg: rgba(0, 0, 0, 0.6);
            --lord-color: #f1c40f;
            --loyal-color: #e67e22;
            --rebel-color: #2ecc71;
            --traitor-color: #9b59b6;
        }

        * { box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- é¡¶éƒ¨ï¼šæ•Œæ–¹åŒºåŸŸ (3ä¸ªAIå¹¶æ’) --- */
        #enemy-zone {
            flex: 0 0 28%; /* å å±å¹•é«˜åº¦çº¦ 28% */
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 5px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid #444;
        }

        .enemy-card {
            width: 31%; /* ä¸‰ç­‰åˆ† */
            height: 95%;
            background: #34495e;
            border: 2px solid #555;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 4px;
            position: relative;
            transition: all 0.2s;
            font-size: 12px;
        }

        .enemy-card.active-turn { border-color: #f1c40f; box-shadow: 0 0 10px #f1c40f; transform: scale(1.02); z-index: 2; }
        .enemy-card.dead { opacity: 0.4; filter: grayscale(100%); border-style: dashed; }
        .enemy-card.targetable { 
            border-color: #e74c3c; 
            box-shadow: 0 0 15px #e74c3c; 
            animation: pulse 0.8s infinite; 
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        .role-badge { 
            font-size: 10px; padding: 1px 4px; border-radius: 4px; 
            background: #7f8c8d; color: white; margin-bottom: 2px;
        }
        .role-lord { background: var(--lord-color); color: black; }
        .role-loyal { background: var(--loyal-color); }
        .role-rebel { background: var(--rebel-color); }
        .role-traitor { background: var(--traitor-color); }

        .general-info { text-align: center; line-height: 1.2; }
        .general-name { font-weight: bold; font-size: 14px; display: block; }
        .skill-name { font-size: 10px; color: #bdc3c7; }

        /* --- ä¸­é—´ï¼šæ—¥å¿—åŒºåŸŸ --- */
        #log-zone {
            flex: 1; /* å æ®å‰©ä½™ç©ºé—´ */
            background: var(--log-bg);
            overflow-y: auto;
            padding: 8px;
            font-size: 13px;
            border-bottom: 1px solid #555;
            text-shadow: 1px 1px 1px black;
        }
        .log-line { margin-bottom: 4px; line-height: 1.4; }
        .log-turn { color: #f1c40f; border-top: 1px dashed #555; margin-top: 4px; padding-top: 2px; }
        .log-damage { color: #e74c3c; font-weight: bold; }
        .log-skill { color: #3498db; font-weight: bold; }

        /* --- åº•éƒ¨ï¼šç©å®¶åŒºåŸŸ --- */
        #player-zone {
            flex: 0 0 45%; /* å å±å¹•é«˜åº¦ 45% */
            display: flex;
            flex-direction: column;
            background: rgba(0,0,0,0.3);
            padding: 5px;
        }

        /* ç©å®¶çŠ¶æ€æ  */
        #player-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            margin-bottom: 5px;
            height: 30px;
        }
        .my-info { font-size: 16px; font-weight: bold; color: #f1c40f; }
        
        /* è¡€æ¡æ ·å¼ */
        .hp-bar { display: flex; gap: 2px; }
        .hp-point { width: 10px; height: 10px; border-radius: 50%; background: #2ecc71; border: 1px solid #fff; }
        .hp-lost { background: #555; border-color: #777; }

        /* æ‰‹ç‰ŒåŒºåŸŸ (æ¨ªå‘æ»šåŠ¨) */
        #hand-scroll-container {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap; /* å…³é”®ï¼šæ¨ªå‘æ’åˆ— */
            padding: 10px 5px;
            -webkit-overflow-scrolling: touch; /* iOSæµç•…æ»šåŠ¨ */
            display: flex;
            align-items: center;
        }

        .card {
            display: inline-flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 65px;
            height: 95px;
            background: #ecf0f1;
            border-radius: 6px;
            margin-right: 8px;
            flex-shrink: 0; /* é˜²æ­¢è¢«å‹ç¼© */
            position: relative;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            transition: transform 0.2s, border 0.2s;
            color: #333;
            font-weight: bold;
        }

        .card.selected { 
            transform: translateY(-15px); 
            border: 3px solid #e74c3c; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.8);
        }

        .card[data-type="æ€"] { color: #c0392b; border-bottom: 3px solid #c0392b; }
        .card[data-type="é—ª"] { color: #2980b9; border-bottom: 3px solid #2980b9; }
        .card[data-type="æ¡ƒ"] { color: #e91e63; border-bottom: 3px solid #e91e63; }
        .card[data-type="ä¸‡ç®­"] { color: #8e44ad; border-bottom: 3px solid #8e44ad; }

        .card-icon { font-size: 24px; margin-bottom: 5px; }
        .card-text { font-size: 14px; }

        /* åº•éƒ¨æŒ‰é’®æ  */
        #controls {
            height: 50px;
            display: flex;
            gap: 10px;
            padding: 5px;
        }
        button {
            flex: 1;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            color: white;
            background: #7f8c8d;
            transition: background 0.2s;
        }
        button:active { transform: scale(0.95); }
        button:disabled { opacity: 0.3; }
        
        #btn-confirm { background: #e67e22; } /* æ©™è‰² */
        #btn-confirm:not(:disabled) { box-shadow: 0 0 10px #e67e22; }
        
        #btn-end { background: #27ae60; } /* ç»¿è‰² */

        /* é®ç½©å±‚ */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100;
        }
        #overlay h1 { font-size: 32px; margin-bottom: 30px; text-align: center; padding: 0 20px; }
        .win { color: #f1c40f; }
        .lose { color: #e74c3c; }

    </style>
</head>
<body>

    <!-- é¡¶éƒ¨ï¼š3ä¸ªAI -->
    <div id="enemy-zone">
        <!-- JS åŠ¨æ€å¡«å…… -->
    </div>

    <!-- ä¸­é—´ï¼šæ—¥å¿— -->
    <div id="log-zone">
        <div class="log-line">æ¬¢è¿æ¥åˆ°ä¸‰å›½æ€ Lite æ‰‹æœºç‰ˆï¼</div>
    </div>

    <!-- åº•éƒ¨ï¼šç©å®¶ -->
    <div id="player-zone">
        <div id="player-status">
            <div class="my-info">ä¸»å…¬ (æ›¹æ“)</div>
            <div class="hp-bar" id="my-hp-bar"></div>
        </div>
        
        <div id="hand-scroll-container">
            <!-- æ‰‹ç‰Œ JS å¡«å…… -->
        </div>

        <div id="controls">
            <button id="btn-confirm" onclick="confirmAction()" disabled>å‡ºç‰Œ</button>
            <button id="btn-cancel" onclick="cancelAction()" disabled>å–æ¶ˆ</button>
            <button id="btn-end" onclick="endTurn()" disabled>ç»“æŸ</button>
        </div>
    </div>

    <!-- ç»“ç®—å¼¹çª— -->
    <div id="overlay">
        <h1 id="game-result-title"></h1>
        <button onclick="location.reload()" style="flex:0; padding: 15px 40px; background:#3498db;">å†æ¥ä¸€å±€</button>
    </div>

<script>
    // --- æ¸¸æˆé…ç½® (é€»è¾‘ä¿æŒä¸å˜) ---
    const GENERALS = [
        { name: 'æ›¹æ“', hp: 5, skill: 'å¥¸é›„', desc: 'å—ä¼¤æ‘¸ç‰Œ' },
        { name: 'å¼ é£', hp: 4, skill: 'å’†å“®', desc: 'æ— é™æ€' },
        { name: 'éƒ­å˜‰', hp: 3, skill: 'é—è®¡', desc: 'å—ä¼¤æ‘¸2' },
        { name: 'èµµäº‘', hp: 4, skill: 'é¾™èƒ†', desc: 'é˜²å¾¡å¼º' }
    ];
    
    const DECK_TEMPLATE = [
        ...Array(20).fill('æ€'),
        ...Array(12).fill('é—ª'),
        ...Array(8).fill('æ¡ƒ'),
        ...Array(3).fill('ä¸‡ç®­')
    ];

    let players = [];
    let deck = [];
    let currentTurnIndex = 0;
    let selectedCardIndex = -1;
    let isTargetingMode = false;
    let gameActive = true;

    // --- åˆå§‹åŒ– ---
    function initGame() {
        deck = [...DECK_TEMPLATE];
        shuffle(deck);

        let aiRoles = ['åè´¼', 'å¿ è‡£', 'å†…å¥¸'];
        shuffle(aiRoles);
        let aiGenerals = GENERALS.slice(1);
        shuffle(aiGenerals);

        // ç©å®¶ (ID 0)
        players.push({
            id: 0, isUser: true, name: 'ä½ ', 
            role: 'ä¸»å…¬', general: GENERALS[0], 
            hp: GENERALS[0].hp, maxHp: GENERALS[0].hp, 
            hand: [], isDead: false, hasAttacked: false
        });

        // AI (ID 1, 2, 3)
        for(let i=0; i<3; i++) {
            players.push({
                id: i+1, isUser: false, name: `AI-${i+1}`,
                role: aiRoles[i], general: aiGenerals[i],
                hp: aiGenerals[i].hp, maxHp: aiGenerals[i].hp,
                hand: [], isDead: false, hasAttacked: false,
                identityKnown: false
            });
        }

        players.forEach(p => drawCards(p, 4));
        renderAll();
        log("æ¸¸æˆå¼€å§‹ï¼å‡»è´¥åè´¼å’Œå†…å¥¸ï¼", "turn");
        startTurn(0);
    }

    // --- æ ¸å¿ƒæµç¨‹ ---
    function startTurn(playerIndex) {
        if (!gameActive) return;
        currentTurnIndex = playerIndex;
        const p = players[playerIndex];

        if (p.isDead) {
            nextTurn();
            return;
        }

        p.hasAttacked = false;
        renderAll(); 

        log(`--- ${p.name} (${p.general.name}) å›åˆ ---`, "turn");
        drawCards(p, 2);
        
        if (p.isUser) {
            updateHandUI();
            updateButtons();
        } else {
            updateButtons(); // ç¦ç”¨æŒ‰é’®
            setTimeout(() => aiAction(p), 800);
        }
    }

    function nextTurn() {
        checkWinCondition();
        if (!gameActive) return;
        let nextIndex = (currentTurnIndex + 1) % 4;
        startTurn(nextIndex);
    }

    // --- ç©å®¶äº¤äº’ ---
    function selectCard(index) {
        if (!players[0].isUser || currentTurnIndex !== 0) return;
        
        if (selectedCardIndex === index) {
            cancelAction(); // åé€‰
        } else {
            selectedCardIndex = index;
            const card = players[0].hand[index];
            if (card === 'æ€') {
                isTargetingMode = true;
                log("è¯·ç‚¹å‡»ä¸Šæ–¹å¤´åƒé€‰æ‹©ç›®æ ‡...");
            } else {
                isTargetingMode = false;
            }
            updateHandUI();
            updateButtons();
            renderEnemies(); // æ›´æ–°ç›®æ ‡é«˜äº®
        }
    }

    function selectTargetPlayer(targetId) {
        if (!isTargetingMode || selectedCardIndex === -1) return;
        const target = players[targetId];
        if (target.isDead) return;

        const card = players[0].hand[selectedCardIndex];
        if (card === 'æ€') {
            if (players[0].hasAttacked && players[0].general.name !== 'å¼ é£') {
                log("æœ¬å›åˆå·²å‡ºè¿‡æ€ï¼");
                cancelAction();
                return;
            }
            useCard(players[0], selectedCardIndex, target);
            cancelAction();
        }
    }

    function confirmAction() {
        if (selectedCardIndex === -1) return;
        const card = players[0].hand[selectedCardIndex];
        if (card === 'æ¡ƒ') useCard(players[0], selectedCardIndex, players[0]);
        else if (card === 'ä¸‡ç®­') useCard(players[0], selectedCardIndex, null);
        cancelAction();
    }

    function cancelAction() {
        selectedCardIndex = -1;
        isTargetingMode = false;
        updateHandUI();
        updateButtons();
        renderEnemies();
    }

    function endTurn() {
        if (currentTurnIndex !== 0) return;
        nextTurn();
    }

    // --- æˆ˜æ–—é€»è¾‘ ---
    function useCard(source, cardIndex, target) {
        const card = source.hand[cardIndex];
        source.hand.splice(cardIndex, 1);

        if (card === 'æ€') {
            log(`${source.name} å¯¹ ${target.name} å‡ºæ€`);
            source.hasAttacked = true;
            resolveAttack(source, target);
        } 
        else if (card === 'æ¡ƒ') {
            if (target.hp < target.maxHp) {
                target.hp++;
                log(`${source.name} åƒæ¡ƒå›è¡€`, "skill");
            } else {
                log(`${source.name} æ»¡è¡€åƒæ¡ƒ(æ— æ•ˆ)`);
            }
        }
        else if (card === 'ä¸‡ç®­') {
            log(`${source.name} æ”¾ä¸‡ç®­é½å‘ï¼`, "skill");
            players.forEach(p => {
                if (p !== source && !p.isDead) resolveAttack(source, p, true);
            });
        }

        renderAll();
    }

    function resolveAttack(source, target, isAOE = false) {
        const shanIndex = target.hand.indexOf('é—ª');
        if (shanIndex !== -1) {
            target.hand.splice(shanIndex, 1);
            log(`${target.name} å‡ºé—ª`, "skill");
        } else {
            target.hp--;
            log(`${target.name} å—åˆ°ä¼¤å®³`, "damage");
            triggerDamageSkill(target);
            
            if (target.hp <= 0) {
                const taoIndex = target.hand.indexOf('æ¡ƒ');
                if (taoIndex !== -1) {
                    target.hand.splice(taoIndex, 1);
                    target.hp++;
                    log(`${target.name} æ¿’æ­»åƒæ¡ƒ`, "skill");
                } else {
                    handleDeath(source, target);
                }
            }
        }
    }

    function triggerDamageSkill(player) {
        if (player.isDead) return;
        if (player.general.name === 'æ›¹æ“') {
            log(`ã€å¥¸é›„ã€‘${player.name}æ‘¸1ç‰Œ`, "skill");
            drawCards(player, 1);
        } else if (player.general.name === 'éƒ­å˜‰') {
            log(`ã€é—è®¡ã€‘${player.name}æ‘¸2ç‰Œ`, "skill");
            drawCards(player, 2);
        }
    }

    function handleDeath(killer, deadPlayer) {
        deadPlayer.isDead = true;
        deadPlayer.identityKnown = true;
        log(`${deadPlayer.name} é˜µäº¡! èº«ä»½:[${deadPlayer.role}]`, "damage");
        
        if (deadPlayer.role === 'åè´¼') {
            log("å‡»æ€åè´¼ï¼Œæ‘¸3å¼ ", "skill");
            drawCards(killer, 3);
        } else if (deadPlayer.role === 'å¿ è‡£' && killer.role === 'ä¸»å…¬') {
            log("ä¸»å…¬æ€å¿ è‡£ï¼Œå¼ƒå…‰æ‰‹ç‰Œ", "damage");
            killer.hand = [];
        }
        checkWinCondition();
    }

    // --- AI ---
    function aiAction(ai) {
        if (ai.isDead || !gameActive) return;

        // åƒæ¡ƒ
        while (ai.hp < ai.maxHp && ai.hand.includes('æ¡ƒ')) {
            useCard(ai, ai.hand.indexOf('æ¡ƒ'), ai);
        }
        // ä¸‡ç®­
        if (ai.hand.includes('ä¸‡ç®­')) {
            useCard(ai, ai.hand.indexOf('ä¸‡ç®­'), null);
            if (!gameActive) return;
        }
        // æ€
        let target = null;
        const alive = players.filter(p => !p.isDead && p !== ai);
        
        if (ai.role === 'åè´¼') target = players[0];
        else if (ai.role === 'å¿ è‡£') {
            const enemies = alive.filter(p => p.role !== 'ä¸»å…¬');
            if (enemies.length) target = enemies[Math.floor(Math.random()*enemies.length)];
        } else {
            target = alive[Math.floor(Math.random()*alive.length)];
        }

        if (target && !target.isDead && ai.hand.includes('æ€')) {
            if (!ai.hasAttacked || ai.general.name === 'å¼ é£') {
                useCard(ai, ai.hand.indexOf('æ€'), target);
            }
        }

        setTimeout(nextTurn, 800);
    }

    // --- è¾…åŠ© ---
    function drawCards(p, n) {
        for(let i=0; i<n; i++) {
            if (deck.length===0) { deck=[...DECK_TEMPLATE]; shuffle(deck); }
            p.hand.push(deck.pop());
        }
    }
    function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    function checkWinCondition() {
        const lord = players[0];
        const rebels = players.filter(p => p.role === 'åè´¼' && !p.isDead);
        const traitor = players.filter(p => p.role === 'å†…å¥¸' && !p.isDead);
        if (lord.isDead) gameOver(false, "ä¸»å…¬é˜µäº¡ï¼Œå¤±è´¥ï¼");
        else if (rebels.length === 0 && traitor.length === 0) gameOver(true, "é€†è´¼å…¨ç­ï¼Œèƒœåˆ©ï¼");
    }
    function gameOver(win, msg) {
        gameActive = false;
        const t = document.getElementById('game-result-title');
        t.innerText = msg;
        t.className = win ? 'win' : 'lose';
        document.getElementById('overlay').style.display = 'flex';
    }
    function log(msg, type="") {
        const box = document.getElementById('log-zone');
        const div = document.createElement('div');
        div.className = `log-line ${type === 'turn' ? 'log-turn' : (type === 'damage' ? 'log-damage' : (type === 'skill' ? 'log-skill' : ''))}`;
        div.innerText = msg;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    }

    // --- UI æ¸²æŸ“ ---
    function renderAll() {
        renderEnemies();
        renderPlayerStatus();
        updateHandUI();
    }

    function renderEnemies() {
        const container = document.getElementById('enemy-zone');
        container.innerHTML = '';
        
        // æ¸²æŸ“ AI (ID 1, 2, 3)
        for(let i=1; i<=3; i++) {
            const p = players[i];
            const div = document.createElement('div');
            
            let roleText = p.identityKnown ? p.role : "???";
            let roleClass = p.identityKnown ? (p.role === 'åè´¼' ? 'role-rebel' : (p.role === 'å¿ è‡£' ? 'role-loyal' : 'role-traitor')) : '';
            
            let classes = `enemy-card ${p.isDead ? 'dead' : ''} ${currentTurnIndex === i ? 'active-turn' : ''}`;
            if (isTargetingMode && !p.isDead) classes += ' targetable';

            div.className = classes;
            div.onclick = () => selectTargetPlayer(i);
            
            div.innerHTML = `
                <div class="role-badge ${roleClass}">${roleText}</div>
                <div class="general-info">
                    <span class="general-name">${p.general.name}</span>
                    <span class="skill-name">[${p.general.skill}]</span>
                </div>
                <div class="hp-bar">${getHpHtml(p.hp, p.maxHp)}</div>
                <div style="font-size:10px; color:#bdc3c7;">æ‰‹ç‰Œ: ${p.hand.length}</div>
            `;
            container.appendChild(div);
        }
    }

    function renderPlayerStatus() {
        const p = players[0];
        document.getElementById('my-hp-bar').innerHTML = getHpHtml(p.hp, p.maxHp);
    }

    function getHpHtml(hp, max) {
        let html = '';
        for(let i=0; i<max; i++) {
            html += `<div class="hp-point ${i < hp ? '' : 'hp-lost'}"></div>`;
        }
        return html;
    }

    function updateHandUI() {
        const container = document.getElementById('hand-scroll-container');
        container.innerHTML = '';
        const p = players[0];

        p.hand.forEach((card, idx) => {
            const el = document.createElement('div');
            el.className = `card ${idx === selectedCardIndex ? 'selected' : ''}`;
            el.setAttribute('data-type', card);
            el.onclick = () => selectCard(idx);
            
            let icon = '';
            if(card==='æ€') icon='âš”ï¸';
            if(card==='é—ª') icon='ğŸ’¨';
            if(card==='æ¡ƒ') icon='ğŸ‘';
            if(card==='ä¸‡ç®­') icon='ğŸ¹';

            el.innerHTML = `<div class="card-icon">${icon}</div><div class="card-text">${card}</div>`;
            container.appendChild(el);
        });
    }

    function updateButtons() {
        const isMyTurn = currentTurnIndex === 0;
        const hasSelected = selectedCardIndex !== -1;
        const card = hasSelected ? players[0].hand[selectedCardIndex] : null;

        document.getElementById('btn-end').disabled = !isMyTurn;
        document.getElementById('btn-cancel').disabled = !hasSelected;
        
        let canConfirm = false;
        if (isMyTurn && hasSelected) {
            if (card === 'æ¡ƒ' && players[0].hp < players[0].maxHp) canConfirm = true;
            if (card === 'ä¸‡ç®­') canConfirm = true;
        }
        document.getElementById('btn-confirm').disabled = !canConfirm;
    }

    initGame();
</script>
</body>
</html>
